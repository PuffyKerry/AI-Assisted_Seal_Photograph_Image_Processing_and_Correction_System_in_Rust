//Dehazing pipeline and endpoint for control flow of Dark Channel Prior-based dehazing
//TODO: significant amount of testing. Reorganize files, a lot. Flesh out usability. Flesh out documentation, somewhere between a tiny bit of polishing and a ridiculous amount (probably closer to the first)

use ndarray::Array3;

use crate::dcp::find_dark_channel;
use crate::atmospheric::estimate_atmospheric_light;
use crate::transmission::{estimated_transmission_map};
use crate::radiance::recover_scene_radiance;
use crate::guided_filter::{guided_filter, rgb_to_grayscale};

/*
Single function for the broad dehazing functionality specified in the Project Plan that combines all the steps needed: dark channel prior calculation (detect haze), atmospheric light color estimation (calculate what light values the haze shifted), transmission map estimation (map out what changes to make to each pixel), refinement → radiance recovery

Purpose: Single entry point for dehazing functionality of the broader IP module
    Calls each component in sequence to handle control flow with sensible default parameters based on the original He et al. paper

Pipeline flow: (generated by AI)
    Format:
        [stage or function]      -> [output]
            |
            v
        [next stage or function]


    Input Image
        │
        ▼
    find_dark_channel        → grayscale haze density map
        │
        ▼
    estimate_atmospheric_light → RGB color of atmospheric haze reflected into the camera
        │
        ▼
    estimate_transmission    → grayscale map of light penetration aka how much light reaches the camera
        │
        ▼
    guided_filter            → refined transmission with clean edges
        │
        ▼
    recover_scene_radiance   → dehazed RGB image

@param: img_3d: input hazy image as a 3D array (height x width x 3, the  x 3 is for RGB) with values in [0, 1]
@param: patch_size: size of patch for dark channel calculation (typically 15 but using 5 for testing purposes)
@return: dehazed image as a 3D array (height x width x 3) with values in [0, 1]
*/
pub fn dehaze_static_test(img_3d: &Array3<f32>, patch_size: usize) -> Array3<f32> { //algorithm parameters based on He et al. paper defaults for testing ease except for OMEGA, T0, patch_size, and GUIDED_RADIUS which were 0.95, 0.1, 15, and 60 in the paper but were changed for performance and image clarity reasons, this was set up by AI (just a few function calls)
    const OMEGA: f32 = 0.75;          //haze retention factor, keeps 25% haze for realism
    const T0: f32 = 0.25;              //minimum transmission to prevent noise in thick haze
    const TOP_PERCENT: f32 = 0.001;   //top 0.1% brightest pixels for atmospheric light estimation
    const GUIDED_RADIUS: usize = 15;  //guided filter window radius
    const GUIDED_EPS: f32 = 0.0001;   //guided filter regularization (smaller = sharper edges)

    let dark_channel = find_dark_channel(img_3d, patch_size); //detect haze with DCP
    println!("dark channel length: {}", dark_channel.len());
    let atmospheric = estimate_atmospheric_light(img_3d, &dark_channel, TOP_PERCENT); //use pixels who have the brightest dark channels to estimate the color of atmospheric light, aka the haze
    println!("atmospheric light length: {}", atmospheric.len());
    let transmission = estimated_transmission_map(img_3d, &atmospheric, patch_size, OMEGA); //raw transmission map
    println!("transmission map length: {}", transmission.len());
    let grayscale = rgb_to_grayscale(img_3d); //refine transmission using guided filter to remove halos produced by DCP's use of patches
    println!("grayscale length: {}", grayscale.len());
    let refined_transmission = guided_filter(&grayscale, &transmission, GUIDED_RADIUS, GUIDED_EPS);
    println!("refined transmission length: {}", refined_transmission.len());
    recover_scene_radiance(img_3d, &refined_transmission, &atmospheric, T0) //recover scene radiance from refined transmission map
}


/*
EXTREMELY. WIP. Same as dehaze_static_test, but now with custom parameters for fine-tuning results by overriding any or all algorithm parameters for experimentation or specific use cases in production

@param: img_3d: input hazy image as a 3D array (height x width x 3) with values in [0, 1]
@param: patch_size: size of patch for dark channel calculation
@param: omega: haze retention factor [0, 1], lower means more haze removal
@param: t0: minimum transmission [0, 1], higher means less noise but less dehaze in thick fog
@param: top_percent: fraction of pixels with the most intense (aka brightest) dark channel for atmospheric light estimation
@param: guided_radius: guided filter window radius, larger = smoother but takes more time to finish, vice versa.
@param: guided_eps: guided filter regularization, smaller = sharper edges but takes more time to finish, vice versa.
@return: dehazed image as a 3D array (height x width x 3) with values in [0, 1]
*/
pub fn dehaze_with_params(img_3d: &Array3<f32>, patch_size: usize, omega: f32, t0: f32, top_percent: f32, guided_radius: usize, guided_eps: f32) -> Array3<f32> {
    let dark_channel = find_dark_channel(img_3d, patch_size);
    let atmospheric = estimate_atmospheric_light(img_3d, &dark_channel, top_percent);
    let transmission = estimated_transmission_map(img_3d, &atmospheric, patch_size, omega);
    let grayscale = rgb_to_grayscale(img_3d);
    let refined_transmission = guided_filter(&grayscale, &transmission, guided_radius, guided_eps);
    recover_scene_radiance(img_3d, &refined_transmission, &atmospheric, t0)
}

